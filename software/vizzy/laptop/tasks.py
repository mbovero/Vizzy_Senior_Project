# vizzy/laptop/tasks.py
from __future__ import annotations

from typing import Any, List, Dict

import cv2
from ultralytics import YOLO

from .motion import Motion
from .memory import ObjectMemory


def execute_plan(
    *,
    plan: List[Dict[str, Any]],  # NEW: List of task dicts from llm_task_scheduler
    motion: Motion,
    memory: ObjectMemory,
    model: YOLO,
    camera: cv2.VideoCapture,
    config: Any,
    frame_sink,  # FrameBus.publish (main-thread renderer)
) -> None:
    """
    Execute a plan generated by the LLM task scheduler.
    
    Plan format: List of task dictionaries with:
      - command: PICK, MOVE_TO, ROTATE, RELEASE, PLACE_TO, RELOCATE
      - target: unique_id or [x, y, z] coordinates (optional)
      - destination: unique_id or [x, y, z] coordinates (optional)
      - parameters: dict of additional command-specific params (optional)
    """
    if not plan:
        print("[Tasks] (noop) No tasks in plan.")
        return

    print(f"[Tasks] Executing plan with {len(plan)} task(s)")

    for i, task in enumerate(plan, start=1):
        command = task.get("command", "").upper()
        target = task.get("target")
        destination = task.get("destination")
        parameters = task.get("parameters", {})
        
        print(f"[Tasks] Task {i}/{len(plan)}: {command}")
        print(f"         target={target}, dest={destination}, params={parameters}")

        # Execute based on command type
        if command == "PICK":
            _do_pick(target, motion, memory, model, camera, frame_sink)

        elif command == "MOVE_TO":
            _do_move_to(destination, motion, memory)

        elif command == "ROTATE":
            _do_rotate(parameters, motion)

        elif command == "RELEASE":
            _do_release(motion)

        elif command == "PLACE_TO":
            _do_place_to(destination, motion, memory)

        elif command == "RELOCATE":
            _do_relocate(target, destination, motion, memory, model, camera, frame_sink)

        else:
            print(f"[Tasks] Unknown command: {command}")


# --------------------------------------------------------------------------- #
# Command Handlers (New LLM Task Scheduler Format)
# --------------------------------------------------------------------------- #

def _resolve_target(target: Any, memory: ObjectMemory) -> dict:
    """
    Resolve a target (unique_id or [x,y,z]) to position info.
    Returns dict with 'type', 'id'/'coords', and 'pwm_btm'/'pwm_top' if available.
    """
    if isinstance(target, str):
        # Unique object ID
        obj = memory.get_object(target)
        if obj:
            return {
                "type": "object_id",
                "id": target,
                "pwm_btm": obj.get("pwm_btm"),
                "pwm_top": obj.get("pwm_top"),
                "x": obj.get("x", 0.0),
                "y": obj.get("y", 0.0),
                "z": obj.get("z", 0.0),
                "cls_name": obj.get("cls_name"),
            }
        else:
            print(f"[Tasks] Warning: Object {target} not found in memory")
            return {"type": "unknown", "id": target}
    
    elif isinstance(target, (list, tuple)) and len(target) == 3:
        # Coordinate array [x, y, z]
        return {
            "type": "coordinates",
            "coords": target,
            "x": float(target[0]),
            "y": float(target[1]),
            "z": float(target[2]),
        }
    
    else:
        print(f"[Tasks] Warning: Invalid target format: {target}")
        return {"type": "invalid"}


def _do_pick(target: Any, motion: Motion, memory: ObjectMemory, model: YOLO, camera: cv2.VideoCapture, frame_sink) -> None:
    """
    PICK command: Move to target, center on it, grasp, return to resting position.
    """
    print("\n" + "="*60)
    print(f"[Tasks] EXECUTING PICK COMMAND")
    print("="*60)
    print(f"[Tasks] Target: {target}")
    
    resolved = _resolve_target(target, memory)
    
    if resolved["type"] == "object_id":
        print(f"[Tasks] Resolved target to object ID: {resolved['id']}")
        print(f"[Tasks] Object class: {resolved.get('cls_name', 'unknown')}")
        print(f"[Tasks] Object position: x={resolved.get('x', 0):.3f}, y={resolved.get('y', 0):.3f}, z={resolved.get('z', 0):.3f}")
        
        if resolved.get("pwm_btm") and resolved.get("pwm_top"):
            print(f"[Tasks] Saved servo positions: BTM={resolved['pwm_btm']}, TOP={resolved['pwm_top']}")
            print(f"[Tasks] SUCCESS: Would move arm to saved position")
        else:
            print(f"[Tasks] WARNING: No saved servo positions for this object")
        
        print(f"[Tasks] SUCCESS: Would center camera on object")
        print(f"[Tasks] SUCCESS: Would close gripper to grasp object")
        print(f"[Tasks] SUCCESS: Would return to resting position")
    
    elif resolved["type"] == "coordinates":
        coords = resolved['coords']
        print(f"[Tasks] Resolved target to coordinates: [{coords[0]:.3f}, {coords[1]:.3f}, {coords[2]:.3f}]")
        print(f"[Tasks] SUCCESS: Would calculate IK for coordinates")
        print(f"[Tasks] SUCCESS: Would move arm to calculated position")
        print(f"[Tasks] SUCCESS: Would close gripper to grasp object")
        print(f"[Tasks] SUCCESS: Would return to resting position")
    
    else:
        print(f"[Tasks] ERROR: Invalid or unknown target: {target}")
        print(f"[Tasks] FAILED: Could not resolve target")
    
    print("="*60)
    print(f"[Tasks] PICK COMMAND COMPLETED")
    print("="*60 + "\n")


def _do_move_to(destination: Any, motion: Motion, memory: ObjectMemory) -> None:
    """
    MOVE_TO command: Move arm to destination (with or without object in claw).
    """
    print("\n" + "="*60)
    print(f"[Tasks] EXECUTING MOVE_TO COMMAND")
    print("="*60)
    print(f"[Tasks] Destination: {destination}")
    
    resolved = _resolve_target(destination, memory)
    
    if resolved["type"] == "object_id":
        print(f"[Tasks] Resolved destination to object ID: {resolved['id']}")
        print(f"[Tasks] Object class: {resolved.get('cls_name', 'unknown')}")
        print(f"[Tasks] Object position: x={resolved.get('x', 0):.3f}, y={resolved.get('y', 0):.3f}, z={resolved.get('z', 0):.3f}")
        
        if resolved.get("pwm_btm") and resolved.get("pwm_top"):
            print(f"[Tasks] Saved servo positions: BTM={resolved['pwm_btm']}, TOP={resolved['pwm_top']}")
            print(f"[Tasks] SUCCESS: Would move arm to saved position")
        else:
            print(f"[Tasks] WARNING: No saved servo positions for this object")
            print(f"[Tasks] FAILED: Cannot move to object without saved position")
    
    elif resolved["type"] == "coordinates":
        coords = resolved['coords']
        print(f"[Tasks] Resolved destination to coordinates: [{coords[0]:.3f}, {coords[1]:.3f}, {coords[2]:.3f}]")
        print(f"[Tasks] SUCCESS: Would calculate IK for coordinates")
        print(f"[Tasks] SUCCESS: Would move arm to calculated position")
    
    else:
        print(f"[Tasks] ERROR: Invalid or unknown destination: {destination}")
        print(f"[Tasks] FAILED: Could not resolve destination")
    
    print("="*60)
    print(f"[Tasks] MOVE_TO COMMAND COMPLETED")
    print("="*60 + "\n")


def _do_rotate(parameters: dict, motion: Motion) -> None:
    """
    ROTATE command: Rotate end-effector in roll/yaw directions.
    """
    print("\n" + "="*60)
    print(f"[Tasks] EXECUTING ROTATE COMMAND")
    print("="*60)
    
    roll = parameters.get("roll", 0)
    yaw = parameters.get("yaw", 0)
    pitch = parameters.get("pitch", 0)
    
    print(f"[Tasks] Rotation parameters:")
    print(f"[Tasks]   - Roll:  {roll}°")
    print(f"[Tasks]   - Yaw:   {yaw}°")
    print(f"[Tasks]   - Pitch: {pitch}°")
    
    if roll != 0 or yaw != 0 or pitch != 0:
        print(f"[Tasks] SUCCESS: Would rotate end-effector by specified angles")
    else:
        print(f"[Tasks] WARNING: No rotation specified (all angles are 0)")
    
    print("="*60)
    print(f"[Tasks] ROTATE COMMAND COMPLETED")
    print("="*60 + "\n")


def _do_release(motion: Motion) -> None:
    """
    RELEASE command: Open claw to release object.
    """
    print("\n" + "="*60)
    print(f"[Tasks] EXECUTING RELEASE COMMAND")
    print("="*60)
    
    print(f"[Tasks] SUCCESS: Would open gripper to release object")
    print(f"[Tasks] Object would be released at current position")
    
    print("="*60)
    print(f"[Tasks] RELEASE COMMAND COMPLETED")
    print("="*60 + "\n")


def _do_place_to(destination: Any, motion: Motion, memory: ObjectMemory) -> None:
    """
    PLACE_TO command: Move to destination and release (assumes object already in claw).
    """
    print("\n" + "="*60)
    print(f"[Tasks] EXECUTING PLACE_TO COMMAND (High-Level)")
    print("="*60)
    print(f"[Tasks] This command combines: MOVE_TO + RELEASE")
    print(f"[Tasks] Destination: {destination}")
    print("-"*60)
    
    # Move to destination
    _do_move_to(destination, motion, memory)
    
    # Release object
    _do_release(motion)
    
    print("="*60)
    print(f"[Tasks] PLACE_TO COMMAND COMPLETED")
    print("="*60 + "\n")


def _do_relocate(target: Any, destination: Any, motion: Motion, memory: ObjectMemory, model: YOLO, camera: cv2.VideoCapture, frame_sink) -> None:
    """
    RELOCATE command: High-level command that combines PICK + PLACE_TO.
    """
    print("\n" + "="*60)
    print(f"[Tasks] EXECUTING RELOCATE COMMAND (High-Level)")
    print("="*60)
    print(f"[Tasks] This command combines: PICK + PLACE_TO")
    print(f"[Tasks] Target: {target}")
    print(f"[Tasks] Destination: {destination}")
    print("-"*60)
    
    # Pick up the target
    _do_pick(target, motion, memory, model, camera, frame_sink)
    
    # Place at destination
    _do_place_to(destination, motion, memory)
    
    print("="*60)
    print(f"[Tasks] RELOCATE COMMAND COMPLETED")
    print("="*60 + "\n")


# --------------------------------------------------------------------------- #
# Helper Functions
# --------------------------------------------------------------------------- #
# (All execution is simulated with print statements only)
