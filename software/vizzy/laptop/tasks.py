# vizzy/laptop/tasks.py
"""
Task execution system for Vizzy robotic arm.

Flow:
1. LLM outputs high-level commands (PICK, PLACE) and primitives (GRAB, RELEASE, MOVE_TO, ROT_YAW, ROT_PITCH)
2. expand_high_level_commands() expands PICK/PLACE into primitive sequences
3. resolve_object_ids_and_offsets() converts object IDs to XYZ coordinates and applies offsets
4. convert_to_protocol_format() converts command names to protocol format (e.g., "MOVE_TO" → {"cmd": P.CMD_MOVE_TO, ...})
5. execute_plan() sends primitives one-at-a-time to RPi via dispatcher
"""

from __future__ import annotations

from typing import Any, List, Dict, Optional
import copy

from ..shared import protocol as P
from ..shared import config as C
from .memory import ObjectMemory


def execute_plan(
    *,
    plan: List[Dict[str, Any]],  # LLM output: high-level + primitives
    dispatcher,  # CommandDispatcher instance
    memory: ObjectMemory,
) -> None:
    """
    Execute a plan generated by the LLM task scheduler.
    
    Steps:
    1. Expand high-level commands (PICK, PLACE) into primitives
    2. Resolve object IDs to XYZ coordinates and apply offsets
    3. Convert to protocol format
    4. Send to RPi via dispatcher
    
    Plan format (from LLM): List of task dictionaries with:
      - command: PICK, PLACE, GRAB, RELEASE, MOVE_TO, ROT_YAW, ROT_PITCH
      - target: object_id or [x_mm, y_mm, z_mm] (for PICK)
      - destination: object_id or [x_mm, y_mm, z_mm] (for PLACE, MOVE_TO)
      - offset: [x_mm, y_mm, z_mm] (optional, for PLACE and MOVE_TO)
      - angle: float (for ROT_YAW, ROT_PITCH)
    """
    if not plan:
        print("[Tasks] (noop) No tasks in plan.")
        return

    print(f"[Tasks] Received plan with {len(plan)} command(s) from LLM")
    
    # Step 1: Expand high-level commands
    print("[Tasks] Step 1: Expanding high-level commands...")
    expanded_plan = expand_high_level_commands(plan, memory)
    print(f"[Tasks] Expanded to {len(expanded_plan)} primitive(s)")
    
    # Step 2: Resolve object IDs and apply offsets
    print("[Tasks] Step 2: Resolving object IDs and applying offsets...")
    resolved_plan = resolve_object_ids_and_offsets(expanded_plan, memory)
    print(f"[Tasks] Resolved {len(resolved_plan)} command(s)")
    
    # Step 3: Convert to IK text format (6-parameter: x, y, z, pitch_rad, yaw_rad, O|C)
    print("[Tasks] Step 3: Converting to IK format...")
    ik_commands = convert_to_ik_format(resolved_plan)
    print(f"[Tasks] Generated {len(ik_commands)} IK command(s)")
    
    # Step 4: Execute via dispatcher
    print("[Tasks] Step 4: Executing via dispatcher...")
    success = dispatcher.execute_ik_commands(ik_commands)
    
    if success:
        print("[Tasks] Plan execution completed successfully!")
    else:
        print("[Tasks] Plan execution FAILED!")


# ============================================================================
# Step 1: Expand High-Level Commands
# ============================================================================

def expand_high_level_commands(plan: List[Dict], memory: ObjectMemory) -> List[Dict]:
    """
    Expand PICK and PLACE into sequences of primitive commands.
    Pass through all other primitives unchanged.
    
    PICK(target) expands to:
      1. RELEASE
      2. MOVE_TO(target + vertical_offset, pitch=0)  # Approach from above while keeping claw out straight
      3. ROT_YAW(grasp_angle)  # from object's orientation in memory
      4. MOVE_TO(target, pitch=-π/2)  # Descend to object
      5. GRAB
      6. MOVE_TO(REST_POSITION, pitch=REST_PITCH_ANGLE)
      7. ROT_YAW(REST_YAW_ANGLE)
    
    PLACE(destination, offset?, yaw_rot?) expands to:
      1. ROT_YAW(yaw_rot)  # Optional rotation before placing
      2. MOVE_TO(destination + offset + vertical_offset, pitch=-π/2)  # Approach from above
      3. RELEASE
      4. MOVE_TO(REST_POSITION, pitch=REST_PITCH_ANGLE)
      5. ROT_YAW(REST_YAW_ANGLE)
    """
    expanded = []
    
    for i, task in enumerate(plan, 1):
        command = task.get("command", "").upper()
        
        if command == "PICK":
            print(f"[Tasks] Expanding PICK command {i}...")
            target = task.get("target")
            
            # Get grasp orientation for this object
            grasp_angle = get_grasp_orientation(target, memory)
            
            # Get object's actual coordinates
            obj_xyz = _resolve_to_xyz(target, memory)
            if obj_xyz is None:
                print(f"[Tasks] Warning: Could not resolve target {target} for PICK, skipping")
                continue
            
            obj_z = obj_xyz[2]  # Object's actual z coordinate
            
            # Expand to primitive sequence:
            # 1. RELEASE (ensure claw is open)
            # 2. MOVE_TO above object with approach offset, pitch=0 (claw out straight)
            # 3. ROT_YAW to optimal grasp orientation
            # 4. MOVE_TO to object (descend with pitch=-π/2)
            # 5. GRAB (close claw)
            # 6. MOVE_TO rest position with rest pitch
            # 7. ROT_YAW to rest yaw angle
            vertical_offset = [0, 0, C.APPROACH_OFFSET_Z]
            expanded.extend([
                {"command": "RELEASE"},
                {"command": "MOVE_TO", "destination": target, "offset": vertical_offset, "pitch": 0.0},  # Approach from above with claw straight
                {"command": "ROT_YAW", "angle": grasp_angle},  # Rotate to grasp orientation
                {"command": "MOVE_TO", "destination": target, "pitch": -90.0},  # Descend to object (pitch = -π/2)
                {"command": "GRAB"},
                {"command": "MOVE_TO", "destination": C.REST_POSITION, "pitch": C.REST_PITCH_ANGLE},
                {"command": "ROT_YAW", "angle": C.REST_YAW_ANGLE},
            ])
            print(f"[Tasks]   Expanded to 7 primitives")
            print(f"[Tasks]   Sequence: RELEASE -> MOVE_TO(above, z={obj_z + C.APPROACH_OFFSET_Z:.1f}mm, pitch=0°) -> ROT_YAW({grasp_angle:.1f}°) -> MOVE_TO(pick, z={obj_z:.1f}mm, pitch=-90°) -> GRAB -> REST")
        
        elif command == "PLACE":
            print(f"[Tasks] Expanding PLACE command {i}...")
            destination = task.get("destination")
            offset = task.get("offset", [0, 0, 0])
            yaw_rot = task.get("yaw_rot", None)  # Optional yaw rotation
            
            # Expand to primitive sequence with approach offset
            vertical_offset = [0, 0, C.APPROACH_OFFSET_Z]
            
            # Combine user offset + vertical approach offset
            combined_offset = [
                offset[0] + vertical_offset[0],
                offset[1] + vertical_offset[1],
                offset[2] + vertical_offset[2]
            ]
            
            primitives = []
            if yaw_rot is not None:
                primitives.append({"command": "ROT_YAW", "angle": yaw_rot})
            
            primitives.extend([
                {"command": "MOVE_TO", "destination": destination, "offset": combined_offset, "pitch": -90.0},
                {"command": "RELEASE"},
                {"command": "MOVE_TO", "destination": C.REST_POSITION, "pitch": C.REST_PITCH_ANGLE},
                {"command": "ROT_YAW", "angle": C.REST_YAW_ANGLE},
            ])
            
            expanded.extend(primitives)
            print(f"[Tasks]   Expanded to {len(primitives)} primitives")
        
        else:
            # Pass through primitives unchanged
            expanded.append(copy.deepcopy(task))
    
    return expanded


def get_grasp_orientation(target: Any, memory: ObjectMemory) -> float:
    """
    Get the grasp orientation (yaw angle) for a target object.
    
    If target is an object ID, retrieves the orientation from memory.
    If target is coordinates, returns default angle (0.0).
    
    Returns:
        Yaw angle in degrees for grasping (converted from radians stored in memory)
    """
    import math
    if isinstance(target, str):
        # Object ID - look up in memory
        obj = memory.get_object(target)
        if obj:
            # Check if object has orientation data
            orientation = obj.get("orientation", {})
            yaw_rad = orientation.get("grasp_yaw", 0.0)
            # Convert from radians (stored) to degrees (expected by ROT_YAW command)
            yaw_deg = math.degrees(yaw_rad)
            print(f"[Tasks] Object {target} grasp angle: {yaw_rad:.4f} rad -> {yaw_deg:.1f}°")
            return yaw_deg
        else:
            print(f"[Tasks] Warning: Object {target} not found in memory, using default angle (0.0°)")
            return 0.0
    else:
        # Coordinates - no object-specific orientation
        return 0.0


# ============================================================================
# Step 2: Resolve Object IDs and Apply Offsets
# ============================================================================

def resolve_object_ids_and_offsets(plan: List[Dict], memory: ObjectMemory) -> List[Dict]:
    """
    Convert object IDs to XYZ coordinates and apply offsets.
    
    Input format:
      {"command": "MOVE_TO", "destination": "0xOBJ123", "offset": [10, 0, 0], "pitch": -90.0}
    
    Output format:
      {"command": "MOVE_TO", "x": 1210, "y": 800, "z": 500, "pitch": -90.0}  # offset applied
    
    For commands without destination/target, passes through unchanged.
    """
    resolved = []
    
    for i, task in enumerate(plan, 1):
        command = task.get("command", "").upper()
        new_task = {"command": command}
        
        if command == "MOVE_TO":
            # Resolve destination and apply offset
            destination = task.get("destination")
            offset = task.get("offset", [0, 0, 0])
            pitch = task.get("pitch", C.REST_PITCH_ANGLE)  # Use specified pitch or default
            
            xyz = _resolve_to_xyz(destination, memory)
            if xyz:
                # Apply offset
                new_task["x"] = xyz[0] + offset[0]
                new_task["y"] = xyz[1] + offset[1]
                new_task["z"] = xyz[2] + offset[2]
                new_task["pitch"] = pitch
                print(f"[Tasks] MOVE_TO resolved: xyz=[{new_task['x']:.1f}, {new_task['y']:.1f}, {new_task['z']:.1f}] mm pitch={new_task['pitch']:.1f}°")
            else:
                print(f"[Tasks] Warning: Could not resolve MOVE_TO destination: {destination}")
                continue  # Skip this command
        
        elif command in ("ROT_YAW", "ROT_PITCH"):
            # Copy angle parameter
            new_task["angle"] = task.get("angle", 0.0)
            print(f"[Tasks] {command} angle: {new_task['angle']:.1f}°")
        
        elif command in ("GRAB", "RELEASE"):
            # No parameters needed
            print(f"[Tasks] {command} (no parameters)")
        
        else:
            print(f"[Tasks] Warning: Unknown command {command}, skipping")
            continue
        
        resolved.append(new_task)
    
    return resolved


def _resolve_to_xyz(target: Any, memory: ObjectMemory) -> Optional[List[float]]:
    """
    Resolve a target (object ID or coordinates) to XYZ coordinates in millimeters.
    Returns [x, y, z] or None if resolution fails.
    """
    if isinstance(target, str):
        obj = memory.get_object(target)
        if obj:
            x = float(obj.get("x", 0.0))
            y = float(obj.get("y", 0.0))
            z = float(obj.get("z", 0.0))
            print(f"[Tasks]   Resolved object {target} to [{x:.1f}, {y:.1f}, {z:.1f}] mm")
            return [x, y, z]
        print(f"[Tasks]   Error: Object {target} not found in memory")
        return None

    if isinstance(target, (list, tuple)) and len(target) == 3:
        x = float(target[0])
        y = float(target[1])
        z = float(target[2])
        print(f"[Tasks]   Using provided coordinates [{x:.1f}, {y:.1f}, {z:.1f}] mm")
        return [x, y, z]

    print(f"[Tasks]   Error: Invalid target format: {target}")
    return None


# ============================================================================
# Step 3: Convert to IK Text Format (6-parameter: x, y, z, pitch_rad, yaw_rad, O|C)
# ============================================================================

def convert_to_ik_format(plan: List[Dict]) -> List[Dict]:
    """
    Convert resolved commands to IK text format.
    
    Format: "ik x y z pitch_rad yaw_rad O|C"
    
    Rules:
    - MOVE_TO: Includes x, y, z, pitch_rad, yaw_rad. Uses previous pitch/yaw if not specified.
    - GRAB: Sets claw to "C" (closed). Combined with preceding or following MOVE_TO.
    - RELEASE: Sets claw to "O" (open). Combined with preceding or following MOVE_TO.
    - ROT_YAW: Updates yaw for subsequent MOVE_TO commands (doesn't send separate command).
    - ROT_PITCH: Updates pitch for subsequent MOVE_TO commands (doesn't send separate command).
    
    Strategy: Process commands and combine GRAB/RELEASE with adjacent MOVE_TO commands.
    
    All coordinates are converted from mm to meters for IK.
    
    Note: Automatically prepends a MOVE_TO rest position at the beginning of any sequence.
    """
    import math
    
    # Prepend MOVE_TO rest position at the beginning of the sequence
    if plan:
        rest_pos = C.REST_POSITION
        rest_move_to = {
            "command": "MOVE_TO",
            "x": float(rest_pos[0]),
            "y": float(rest_pos[1]),
            "z": float(rest_pos[2]),
            "pitch": C.REST_PITCH_ANGLE,
        }
        # Insert at the beginning
        plan = [rest_move_to] + plan
        print(f"[Tasks] Prepend MOVE_TO rest position: [{rest_pos[0]}, {rest_pos[1]}, {rest_pos[2]}] mm, pitch={C.REST_PITCH_ANGLE}°")
    
    ik_commands = []
    
    # State tracking (defaults from REST position)
    current_pitch_deg = C.REST_PITCH_ANGLE  # degrees
    current_yaw_deg = C.REST_YAW_ANGLE  # degrees
    current_claw = "O"  # Open by default
    
    # Track pending yaw/pitch changes that will apply to next MOVE_TO
    pending_yaw_deg = None
    pending_pitch_deg = None
    
    i = 0
    while i < len(plan):
        task = plan[i]
        command = task.get("command", "").upper()
        
        if command == "MOVE_TO":
            # Get coordinates (in mm) and convert to meters
            x_mm = task.get("x", 0.0)
            y_mm = task.get("y", 0.0)
            z_mm = task.get("z", 0.0)
            
            x_m = x_mm / 1000.0
            y_m = y_mm / 1000.0
            z_m = z_mm / 1000.0
            
            # Get pitch: use specified, pending, or current
            pitch_deg = task.get("pitch")
            if pitch_deg is not None:
                current_pitch_deg = float(pitch_deg)
            elif pending_pitch_deg is not None:
                current_pitch_deg = pending_pitch_deg
                pending_pitch_deg = None
            
            # Yaw: use pending or current (MOVE_TO doesn't specify yaw directly)
            if pending_yaw_deg is not None:
                current_yaw_deg = pending_yaw_deg
                pending_yaw_deg = None
            
            # Use current claw state (don't combine with next GRAB/RELEASE to allow separate commands)
            claw_state = current_claw
            
            # Convert to radians
            pitch_rad = math.radians(current_pitch_deg)
            yaw_rad = math.radians(current_yaw_deg)
            
            # Create IK command
            ik_commands.append({
                "type": "ik",
                "x": x_m,
                "y": y_m,
                "z": z_m,
                "pitch_rad": pitch_rad,
                "yaw_rad": yaw_rad,
                "claw": claw_state,
            })
            print(f"[Tasks] IK command: x={x_m:.3f}m y={y_m:.3f}m z={z_m:.3f}m pitch={current_pitch_deg:.1f}° ({pitch_rad:.3f}rad) yaw={current_yaw_deg:.1f}° ({yaw_rad:.3f}rad) claw={claw_state}")
        
        elif command == "GRAB":
            # Create a new IK command at the same position as the last MOVE_TO, but with claw closed
            if len(ik_commands) > 0:
                # Get the last IK command's position and pose
                last_cmd = ik_commands[-1]
                # Create a new command with the same position/pose but claw closed
                ik_commands.append({
                    "type": "ik",
                    "x": last_cmd["x"],
                    "y": last_cmd["y"],
                    "z": last_cmd["z"],
                    "pitch_rad": last_cmd["pitch_rad"],
                    "yaw_rad": last_cmd["yaw_rad"],
                    "claw": "C",
                })
                current_claw = "C"
                print(f"[Tasks] GRAB: created new IK command at same position with claw closed")
            else:
                # No previous MOVE_TO, update state for next MOVE_TO
                current_claw = "C"
                print(f"[Tasks] GRAB: claw set to {current_claw} (will apply to next MOVE_TO)")
        
        elif command == "RELEASE":
            # Create a new IK command at the same position as the last MOVE_TO, but with claw open
            if len(ik_commands) > 0:
                # Get the last IK command's position and pose
                last_cmd = ik_commands[-1]
                # Create a new command with the same position/pose but claw open
                ik_commands.append({
                    "type": "ik",
                    "x": last_cmd["x"],
                    "y": last_cmd["y"],
                    "z": last_cmd["z"],
                    "pitch_rad": last_cmd["pitch_rad"],
                    "yaw_rad": last_cmd["yaw_rad"],
                    "claw": "O",
                })
                current_claw = "O"
                print(f"[Tasks] RELEASE: created new IK command at same position with claw open")
            else:
                # No previous MOVE_TO, update state for next MOVE_TO
                current_claw = "O"
                print(f"[Tasks] RELEASE: claw set to {current_claw} (will apply to next MOVE_TO)")
        
        elif command == "ROT_YAW":
            # Update yaw for next MOVE_TO command
            yaw_deg = task.get("angle", 0.0)
            pending_yaw_deg = float(yaw_deg)
            print(f"[Tasks] ROT_YAW: yaw set to {yaw_deg:.1f}° (will apply to next MOVE_TO)")
        
        elif command == "ROT_PITCH":
            # Update pitch for next MOVE_TO command
            pitch_deg = task.get("angle", 0.0)
            pending_pitch_deg = float(pitch_deg)
            print(f"[Tasks] ROT_PITCH: pitch set to {pitch_deg:.1f}° (will apply to next MOVE_TO)")
        
        else:
            print(f"[Tasks] Warning: Unknown command {command} in IK conversion")
        
        i += 1
    
    return ik_commands
