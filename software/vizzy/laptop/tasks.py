# vizzy/laptop/tasks.py
"""
Task execution system for Vizzy robotic arm.

Flow:
1. LLM outputs high-level commands (PICK, PLACE) and primitives (GRAB, RELEASE, MOVE_TO, ROT_YAW, ROT_PITCH)
2. expand_high_level_commands() expands PICK/PLACE into primitive sequences
3. resolve_object_ids_and_offsets() converts object IDs to XYZ coordinates and applies offsets
4. convert_to_protocol_format() converts command names to protocol format (e.g., "MOVE_TO" → {"cmd": P.CMD_MOVE_TO, ...})
5. execute_plan() sends primitives one-at-a-time to RPi via dispatcher
"""

from __future__ import annotations

from typing import Any, List, Dict, Optional
import copy

from ..shared import protocol as P
from ..shared import config as C
from .memory import ObjectMemory


def execute_plan(
    *,
    plan: List[Dict[str, Any]],  # LLM output: high-level + primitives
    dispatcher,  # CommandDispatcher instance
    memory: ObjectMemory,
) -> None:
    """
    Execute a plan generated by the LLM task scheduler.
    
    Steps:
    1. Expand high-level commands (PICK, PLACE) into primitives
    2. Resolve object IDs to XYZ coordinates and apply offsets
    3. Convert to protocol format
    4. Send to RPi via dispatcher
    
    Plan format (from LLM): List of task dictionaries with:
      - command: PICK, PLACE, GRAB, RELEASE, MOVE_TO, ROT_YAW, ROT_PITCH
      - target: object_id or [x_mm, y_mm, z_mm] (for PICK)
      - destination: object_id or [x_mm, y_mm, z_mm] (for PLACE, MOVE_TO)
      - offset: [x_mm, y_mm, z_mm] (optional, for PLACE and MOVE_TO)
      - angle: float (for ROT_YAW, ROT_PITCH)
    """
    if not plan:
        print("[Tasks] (noop) No tasks in plan.")
        return

    print(f"[Tasks] Received plan with {len(plan)} command(s) from LLM")
    
    # Step 1: Expand high-level commands
    print("[Tasks] Step 1: Expanding high-level commands...")
    expanded_plan = expand_high_level_commands(plan, memory)
    print(f"[Tasks] Expanded to {len(expanded_plan)} primitive(s)")
    
    # Step 2: Resolve object IDs and apply offsets
    print("[Tasks] Step 2: Resolving object IDs and applying offsets...")
    resolved_plan = resolve_object_ids_and_offsets(expanded_plan, memory)
    print(f"[Tasks] Resolved {len(resolved_plan)} command(s)")
    
    # Step 3: Convert to IK text format (6-parameter: x, y, z, pitch_rad, yaw_rad, O|C)
    print("[Tasks] Step 3: Converting to IK format...")
    ik_commands = convert_to_ik_format(resolved_plan)
    print(f"[Tasks] Generated {len(ik_commands)} IK command(s)")
    
    # Step 4: Execute via dispatcher
    print("[Tasks] Step 4: Executing via dispatcher...")
    success = dispatcher.execute_ik_commands(ik_commands)
    
    if success:
        print("[Tasks] Plan execution completed successfully!")
    else:
        print("[Tasks] Plan execution FAILED!")


# ============================================================================
# Step 1: Expand High-Level Commands
# ============================================================================

def expand_high_level_commands(plan: List[Dict], memory: ObjectMemory) -> List[Dict]:
    """
    Expand PICK and PLACE into sequences of primitive commands.
    Pass through all other primitives unchanged.
    
    PICK(target) expands to:
      1. RELEASE
      2. MOVE_TO(target + vertical_offset, pitch=0, yaw=center_yaw, claw=O)  # Approach from above with claw straight
      3. MOVE_TO(pitch=-π/2, yaw=grasp_angle)  # Change pitch and yaw, keep position and claw
      4. MOVE_TO(target)  # Move to target, keep pitch/yaw/claw from step 3
      5. GRAB  # Close claw, keep position and orientation
      6. MOVE_TO(REST_POSITION, pitch=REST_PITCH_ANGLE, yaw=REST_YAW_ANGLE)  # Move to rest, claw still closed
    
    PLACE(destination, offset?, yaw_rot?) expands to:
      1. ROT_YAW(yaw_rot)  # Optional rotation before placing
      2. MOVE_TO(destination + offset + vertical_offset, pitch=-π/2)  # Approach from above
      3. RELEASE
      4. MOVE_TO(REST_POSITION, pitch=REST_PITCH_ANGLE)
      5. ROT_YAW(REST_YAW_ANGLE)
    """
    expanded = []
    
    for i, task in enumerate(plan, 1):
        command = task.get("command", "").upper()
        
        if command == "PICK":
            print(f"[Tasks] Expanding PICK command {i}...")
            target = task.get("target")
            
            # Get grasp orientation for this object
            grasp_angle = get_grasp_orientation(target, memory)
            
            # Get object's actual coordinates
            obj_xyz = _resolve_to_xyz(target, memory)
            if obj_xyz is None:
                print(f"[Tasks] Warning: Could not resolve target {target} for PICK, skipping")
                continue
            
            obj_z = obj_xyz[2]  # Object's actual z coordinate
            
            # Expand to primitive sequence using enhanced MOVE_TO with partial parameters:
            # 1. MOVE_TO(target + vertical_offset, pitch=0, yaw=center_yaw, claw=O)
            # 2. MOVE_TO(pitch=-π/2, yaw=grasp_angle)  # Use other prev parameters (x, y, z, claw from step 1)
            # 3. MOVE_TO(target)  # Use other prev parameters (pitch, yaw, claw from step 2)
            # 4. GRAB  # Use other prev parameters (all from step 3)
            # 5. MOVE_TO(REST_POS, REST_PITCH, REST_YAW)  # Still closed
            vertical_offset = [0, 0, C.APPROACH_OFFSET_Z]
            expanded.extend([
                {"command": "RELEASE"},  # Ensure claw is open initially
                {"command": "MOVE_TO", "destination": target, "offset": vertical_offset, "pitch": 0.0, "yaw": 0.0, "claw": "O"},  # Approach from above with claw straight (center yaw = 0°)
                {"command": "MOVE_TO", "pitch": -90.0, "yaw": grasp_angle},  # Change pitch and yaw, keep position and claw from step 1
                {"command": "MOVE_TO", "destination": target},  # Move to target, keep pitch/yaw/claw from step 2
                {"command": "GRAB"},  # Close claw, keep position and orientation from step 3
                {"command": "MOVE_TO", "destination": C.REST_POSITION, "pitch": C.REST_PITCH_ANGLE, "yaw": C.REST_YAW_ANGLE},  # Move to rest, claw still closed from step 4
            ])
            print(f"[Tasks]   Expanded to 6 primitives")
            print(f"[Tasks]   Sequence: RELEASE -> MOVE_TO(above, z={obj_z + C.APPROACH_OFFSET_Z:.1f}mm, pitch=0°, yaw=0°) -> MOVE_TO(pitch=-90°, yaw={grasp_angle:.1f}°) -> MOVE_TO(target, z={obj_z:.1f}mm) -> GRAB -> MOVE_TO(rest)")
        
        elif command == "PLACE":
            print(f"[Tasks] Expanding PLACE command {i}...")
            destination = task.get("destination")
            offset = task.get("offset", [0, 0, 0])
            yaw_rot = task.get("yaw_rot", None)  # Optional yaw rotation
            
            # Expand to primitive sequence with approach offset
            vertical_offset = [0, 0, C.APPROACH_OFFSET_Z]
            
            # Combine user offset + vertical approach offset
            combined_offset = [
                offset[0] + vertical_offset[0],
                offset[1] + vertical_offset[1],
                offset[2] + vertical_offset[2]
            ]
            
            primitives = []
            if yaw_rot is not None:
                primitives.append({"command": "ROT_YAW", "angle": yaw_rot})
            
            primitives.extend([
                {"command": "MOVE_TO", "destination": destination, "offset": combined_offset, "pitch": -90.0},
                {"command": "RELEASE"},
                {"command": "MOVE_TO", "destination": C.REST_POSITION, "pitch": C.REST_PITCH_ANGLE},
                {"command": "ROT_YAW", "angle": C.REST_YAW_ANGLE},
            ])
            
            expanded.extend(primitives)
            print(f"[Tasks]   Expanded to {len(primitives)} primitives")
        
        else:
            # Pass through primitives unchanged
            expanded.append(copy.deepcopy(task))
    
    return expanded


def get_grasp_orientation(target: Any, memory: ObjectMemory) -> float:
    """
    Get the grasp orientation (yaw angle) for a target object.
    
    If target is an object ID, retrieves the orientation from memory.
    If target is coordinates, returns default angle (0.0).
    
    Returns:
        Yaw angle in degrees for grasping (converted from radians stored in memory)
    """
    import math
    if isinstance(target, str):
        # Object ID - look up in memory
        obj = memory.get_object(target)
        if obj:
            # Check if object has orientation data
            orientation = obj.get("orientation", {})
            yaw_rad = orientation.get("grasp_yaw", 0.0)
            # Convert from radians (stored) to degrees (expected by ROT_YAW command)
            yaw_deg = math.degrees(yaw_rad)
            print(f"[Tasks] Object {target} grasp angle: {yaw_rad:.4f} rad -> {yaw_deg:.1f}°")
            return yaw_deg
        else:
            print(f"[Tasks] Warning: Object {target} not found in memory, using default angle (0.0°)")
            return 0.0
    else:
        # Coordinates - no object-specific orientation
        return 0.0


# ============================================================================
# Step 2: Resolve Object IDs and Apply Offsets
# ============================================================================

def resolve_object_ids_and_offsets(plan: List[Dict], memory: ObjectMemory) -> List[Dict]:
    """
    Convert object IDs to XYZ coordinates and apply offsets.
    
    Input format:
      {"command": "MOVE_TO", "destination": "0xOBJ123", "offset": [10, 0, 0], "pitch": -90.0}
    
    Output format:
      {"command": "MOVE_TO", "x": 1210, "y": 800, "z": 500, "pitch": -90.0}  # offset applied
    
    For commands without destination/target, passes through unchanged.
    """
    resolved = []
    
    for i, task in enumerate(plan, 1):
        command = task.get("command", "").upper()
        new_task = {"command": command}
        
        if command == "MOVE_TO":
            # Enhanced MOVE_TO: Can specify any subset of x, y, z, pitch, yaw, claw
            # OR use destination/offset (backwards compatible)
            # Unspecified parameters will be filled from last known values in convert_to_ik_format
            
            # Check if x, y, z are specified directly
            if "x" in task or "y" in task or "z" in task:
                # Direct coordinate specification
                new_task["x"] = task.get("x")
                new_task["y"] = task.get("y")
                new_task["z"] = task.get("z")
            elif "destination" in task:
                # Resolve destination and apply offset
                destination = task.get("destination")
                offset = task.get("offset", [0, 0, 0])
                xyz = _resolve_to_xyz(destination, memory)
                if xyz:
                    # Apply offset
                    new_task["x"] = xyz[0] + offset[0]
                    new_task["y"] = xyz[1] + offset[1]
                    new_task["z"] = xyz[2] + offset[2]
                else:
                    print(f"[Tasks] Warning: Could not resolve MOVE_TO destination: {destination}")
                    continue  # Skip this command
            # If neither x/y/z nor destination specified, leave them as None (will use last known)
            
            # Optional parameters: pitch, yaw, claw
            if "pitch" in task:
                new_task["pitch"] = task.get("pitch")
            if "yaw" in task:
                new_task["yaw"] = task.get("yaw")
            if "claw" in task:
                new_task["claw"] = task.get("claw")
            
            # Build description for logging
            params = []
            if "x" in new_task and new_task["x"] is not None:
                params.append(f"x={new_task['x']:.1f}")
            if "y" in new_task and new_task["y"] is not None:
                params.append(f"y={new_task['y']:.1f}")
            if "z" in new_task and new_task["z"] is not None:
                params.append(f"z={new_task['z']:.1f}")
            if "pitch" in new_task:
                params.append(f"pitch={new_task['pitch']:.1f}°")
            if "yaw" in new_task:
                params.append(f"yaw={new_task['yaw']:.1f}°")
            if "claw" in new_task:
                params.append(f"claw={new_task['claw']}")
            print(f"[Tasks] MOVE_TO resolved: {', '.join(params) if params else 'partial (using last known values)'}")
        
        elif command in ("ROT_YAW", "ROT_PITCH"):
            # Copy angle parameter
            new_task["angle"] = task.get("angle", 0.0)
            print(f"[Tasks] {command} angle: {new_task['angle']:.1f}°")
        
        elif command in ("GRAB", "RELEASE"):
            # No parameters needed
            print(f"[Tasks] {command} (no parameters)")
        
        else:
            print(f"[Tasks] Warning: Unknown command {command}, skipping")
            continue
        
        resolved.append(new_task)
    
    return resolved


def _resolve_to_xyz(target: Any, memory: ObjectMemory) -> Optional[List[float]]:
    """
    Resolve a target (object ID or coordinates) to XYZ coordinates in millimeters.
    Returns [x, y, z] or None if resolution fails.
    """
    if isinstance(target, str):
        obj = memory.get_object(target)
        if obj:
            x = float(obj.get("x", 0.0))
            y = float(obj.get("y", 0.0))
            z = float(obj.get("z", 0.0))
            print(f"[Tasks]   Resolved object {target} to [{x:.1f}, {y:.1f}, {z:.1f}] mm")
            return [x, y, z]
        print(f"[Tasks]   Error: Object {target} not found in memory")
        return None

    if isinstance(target, (list, tuple)) and len(target) == 3:
        x = float(target[0])
        y = float(target[1])
        z = float(target[2])
        print(f"[Tasks]   Using provided coordinates [{x:.1f}, {y:.1f}, {z:.1f}] mm")
        return [x, y, z]

    print(f"[Tasks]   Error: Invalid target format: {target}")
    return None


# ============================================================================
# Step 3: Convert to IK Text Format (6-parameter: x, y, z, pitch_rad, yaw_rad, O|C)
# ============================================================================

def convert_to_ik_format(plan: List[Dict]) -> List[Dict]:
    """
    Convert resolved commands to IK text format.
    
    Format: "ik x y z pitch_rad yaw_rad O|C"
    
    Rules:
    - MOVE_TO: Includes x, y, z, pitch_rad, yaw_rad. Uses current pitch/yaw state if not specified.
    - GRAB: Creates IK command at same position as last command, only changing claw to "C" (closed).
    - RELEASE: Creates IK command at same position as last command, only changing claw to "O" (open).
    - ROT_YAW: Creates IK command at same position as last command, only changing yaw angle (servo-only movement).
    - ROT_PITCH: Creates IK command at same position as last command, only changing pitch angle (servo-only movement).
    
    Strategy: Each command creates its own IK command. ROT_YAW/ROT_PITCH keep arm position unchanged
    and only move servo motors, allowing "arbitrary" claw rotations at a fixed position.
    
    All coordinates are converted from mm to meters for IK.
    
    Note: Automatically prepends a MOVE_TO rest position at the beginning of any sequence.
    """
    import math
    
    # Prepend MOVE_TO rest position at the beginning of the sequence
    if plan:
        rest_pos = C.REST_POSITION
        rest_move_to = {
            "command": "MOVE_TO",
            "x": float(rest_pos[0]),
            "y": float(rest_pos[1]),
            "z": float(rest_pos[2]),
            "pitch": C.REST_PITCH_ANGLE,
        }
        # Insert at the beginning
        plan = [rest_move_to] + plan
        print(f"[Tasks] Prepend MOVE_TO rest position: [{rest_pos[0]}, {rest_pos[1]}, {rest_pos[2]}] mm, pitch={C.REST_PITCH_ANGLE}°")
    
    ik_commands = []
    
    # State tracking (defaults from REST position)
    # Track all 6 IK parameters from last command for partial MOVE_TO support
    last_x_m = C.REST_POSITION[0] / 1000.0  # meters
    last_y_m = C.REST_POSITION[1] / 1000.0  # meters
    last_z_m = C.REST_POSITION[2] / 1000.0  # meters
    current_pitch_deg = C.REST_PITCH_ANGLE  # degrees
    current_yaw_deg = C.REST_YAW_ANGLE  # degrees
    current_claw = "O"  # Open by default
    
    i = 0
    while i < len(plan):
        task = plan[i]
        command = task.get("command", "").upper()
        
        if command == "MOVE_TO":
            # Enhanced MOVE_TO: Use specified parameters or fall back to last known values
            # Get coordinates: use specified or last known
            if task.get("x") is not None:
                last_x_m = float(task.get("x")) / 1000.0
            if task.get("y") is not None:
                last_y_m = float(task.get("y")) / 1000.0
            if task.get("z") is not None:
                last_z_m = float(task.get("z")) / 1000.0
            
            # Get pitch: use specified or last known
            if task.get("pitch") is not None:
                current_pitch_deg = float(task.get("pitch"))
            
            # Get yaw: use specified or last known (now MOVE_TO can specify yaw directly)
            if task.get("yaw") is not None:
                current_yaw_deg = float(task.get("yaw"))
            
            # Get claw: use specified or last known
            if task.get("claw") is not None:
                claw_state = task.get("claw").upper()
                if claw_state not in ("O", "C"):
                    print(f"[Tasks] Warning: Invalid claw state '{claw_state}', using '{current_claw}'")
                    claw_state = current_claw
                else:
                    current_claw = claw_state
            else:
                claw_state = current_claw
            
            # Convert to radians
            pitch_rad = math.radians(current_pitch_deg)
            yaw_rad = math.radians(current_yaw_deg)
            
            # Create IK command
            ik_commands.append({
                "type": "ik",
                "x": last_x_m,
                "y": last_y_m,
                "z": last_z_m,
                "pitch_rad": pitch_rad,
                "yaw_rad": yaw_rad,
                "claw": claw_state,
            })
            print(f"[Tasks] IK command: x={last_x_m:.3f}m y={last_y_m:.3f}m z={last_z_m:.3f}m pitch={current_pitch_deg:.1f}° ({pitch_rad:.3f}rad) yaw={current_yaw_deg:.1f}° ({yaw_rad:.3f}rad) claw={claw_state}")
        
        elif command == "GRAB":
            # Create a new IK command at the same position as the last command, but with claw closed
            # Update state tracking
            current_claw = "C"
            
            if len(ik_commands) > 0:
                # Get the last IK command's position and pose
                last_cmd = ik_commands[-1]
                # Update last known values
                last_x_m = last_cmd["x"]
                last_y_m = last_cmd["y"]
                last_z_m = last_cmd["z"]
                current_pitch_deg = math.degrees(last_cmd["pitch_rad"])
                current_yaw_deg = math.degrees(last_cmd["yaw_rad"])
                
                # Create a new command with the same position/pose but claw closed
                ik_commands.append({
                    "type": "ik",
                    "x": last_x_m,
                    "y": last_y_m,
                    "z": last_z_m,
                    "pitch_rad": last_cmd["pitch_rad"],
                    "yaw_rad": last_cmd["yaw_rad"],
                    "claw": "C",
                })
                print(f"[Tasks] GRAB: created new IK command at same position with claw closed")
            else:
                # No previous command, update state for next MOVE_TO
                print(f"[Tasks] GRAB: claw set to {current_claw} (will apply to next MOVE_TO)")
        
        elif command == "RELEASE":
            # Create a new IK command at the same position as the last command, but with claw open
            # Update state tracking
            current_claw = "O"
            
            if len(ik_commands) > 0:
                # Get the last IK command's position and pose
                last_cmd = ik_commands[-1]
                # Update last known values
                last_x_m = last_cmd["x"]
                last_y_m = last_cmd["y"]
                last_z_m = last_cmd["z"]
                current_pitch_deg = math.degrees(last_cmd["pitch_rad"])
                current_yaw_deg = math.degrees(last_cmd["yaw_rad"])
                
                # Create a new command with the same position/pose but claw open
                ik_commands.append({
                    "type": "ik",
                    "x": last_x_m,
                    "y": last_y_m,
                    "z": last_z_m,
                    "pitch_rad": last_cmd["pitch_rad"],
                    "yaw_rad": last_cmd["yaw_rad"],
                    "claw": "O",
                })
                print(f"[Tasks] RELEASE: created new IK command at same position with claw open")
            else:
                # No previous command, update state for next MOVE_TO
                print(f"[Tasks] RELEASE: claw set to {current_claw} (will apply to next MOVE_TO)")
        
        elif command == "ROT_YAW":
            # Create IK command at same position, only changing yaw (servo-only movement)
            yaw_deg = task.get("angle", 0.0)
            current_yaw_deg = float(yaw_deg)
            
            if len(ik_commands) > 0:
                # Get the last IK command's position and pose
                last_cmd = ik_commands[-1]
                # Update last known values
                last_x_m = last_cmd["x"]
                last_y_m = last_cmd["y"]
                last_z_m = last_cmd["z"]
                current_pitch_deg = math.degrees(last_cmd["pitch_rad"])
                
                # Create a new command with the same position/pose but new yaw
                ik_commands.append({
                    "type": "ik",
                    "x": last_x_m,
                    "y": last_y_m,
                    "z": last_z_m,
                    "pitch_rad": last_cmd["pitch_rad"],  # Keep previous pitch
                    "yaw_rad": math.radians(current_yaw_deg),  # New yaw
                    "claw": last_cmd["claw"],  # Keep previous claw state
                })
                print(f"[Tasks] ROT_YAW: created IK command at same position with yaw={current_yaw_deg:.1f}° (servo-only)")
            else:
                # No previous command - use rest position (shouldn't happen due to prepended rest, but handle gracefully)
                print(f"[Tasks] ROT_YAW: no previous command, yaw set to {current_yaw_deg:.1f}° (will apply to next MOVE_TO)")
        
        elif command == "ROT_PITCH":
            # Create IK command at same position, only changing pitch (servo-only movement)
            pitch_deg = task.get("angle", 0.0)
            current_pitch_deg = float(pitch_deg)
            
            if len(ik_commands) > 0:
                # Get the last IK command's position and pose
                last_cmd = ik_commands[-1]
                # Update last known values
                last_x_m = last_cmd["x"]
                last_y_m = last_cmd["y"]
                last_z_m = last_cmd["z"]
                current_yaw_deg = math.degrees(last_cmd["yaw_rad"])
                
                # Create a new command with the same position/pose but new pitch
                ik_commands.append({
                    "type": "ik",
                    "x": last_x_m,
                    "y": last_y_m,
                    "z": last_z_m,
                    "pitch_rad": math.radians(current_pitch_deg),  # New pitch
                    "yaw_rad": last_cmd["yaw_rad"],  # Keep previous yaw
                    "claw": last_cmd["claw"],  # Keep previous claw state
                })
                print(f"[Tasks] ROT_PITCH: created IK command at same position with pitch={current_pitch_deg:.1f}° (servo-only)")
            else:
                # No previous command - use rest position (shouldn't happen due to prepended rest, but handle gracefully)
                print(f"[Tasks] ROT_PITCH: no previous command, pitch set to {current_pitch_deg:.1f}° (will apply to next MOVE_TO)")
        
        else:
            print(f"[Tasks] Warning: Unknown command {command} in IK conversion")
        
        i += 1
    
    return ik_commands
