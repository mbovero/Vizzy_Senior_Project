# vizzy/laptop/tasks.py
"""
Task execution system for Vizzy robotic arm.

Flow:
1. LLM outputs high-level commands (PICK, PLACE) and primitives (GRAB, RELEASE, MOVE_TO, ROT_YAW, ROT_PITCH)
2. expand_high_level_commands() expands PICK/PLACE into primitive sequences
3. resolve_object_ids_and_offsets() converts object IDs to XYZ coordinates and applies offsets
4. convert_to_protocol_format() converts command names to protocol format (e.g., "MOVE_TO" → {"cmd": P.CMD_MOVE_TO, ...})
5. execute_plan() sends primitives one-at-a-time to RPi via dispatcher
"""

from __future__ import annotations

from typing import Any, List, Dict, Optional
import copy

from ..shared import protocol as P
from ..shared import config as C
from .memory import ObjectMemory


def execute_plan(
    *,
    plan: List[Dict[str, Any]],  # LLM output: high-level + primitives
    dispatcher,  # CommandDispatcher instance
    memory: ObjectMemory,
) -> None:
    """
    Execute a plan generated by the LLM task scheduler.
    
    Steps:
    1. Expand high-level commands (PICK, PLACE) into primitives
    2. Resolve object IDs to XYZ coordinates and apply offsets
    3. Convert to protocol format
    4. Send to RPi via dispatcher
    
    Plan format (from LLM): List of task dictionaries with:
      - command: PICK, PLACE, GRAB, RELEASE, MOVE_TO, ROT_YAW, ROT_PITCH
      - target: object_id or [x_mm, y_mm, z_mm] (for PICK)
      - destination: object_id or [x_mm, y_mm, z_mm] (for PLACE, MOVE_TO)
      - offset: [x_mm, y_mm, z_mm] (optional, for PLACE and MOVE_TO)
      - angle: float (for ROT_YAW, ROT_PITCH)
    """
    if not plan:
        print("[Tasks] (noop) No tasks in plan.")
        return

    print(f"[Tasks] Received plan with {len(plan)} command(s) from LLM")
    
    # Step 1: Expand high-level commands
    print("[Tasks] Step 1: Expanding high-level commands...")
    expanded_plan = expand_high_level_commands(plan, memory)
    print(f"[Tasks] Expanded to {len(expanded_plan)} primitive(s)")
    
    # Step 2: Resolve object IDs and apply offsets
    print("[Tasks] Step 2: Resolving object IDs and applying offsets...")
    resolved_plan = resolve_object_ids_and_offsets(expanded_plan, memory)
    print(f"[Tasks] Resolved {len(resolved_plan)} command(s)")
    
    # Step 3: Convert to protocol format
    print("[Tasks] Step 3: Converting to protocol format...")
    protocol_commands = convert_to_protocol_format(resolved_plan)
    print(f"[Tasks] Generated {len(protocol_commands)} protocol command(s)")
    
    # Step 4: Execute via dispatcher
    print("[Tasks] Step 4: Executing via dispatcher...")
    success = dispatcher.execute_primitives(protocol_commands)
    
    if success:
        print("[Tasks] Plan execution completed successfully!")
    else:
        print("[Tasks] Plan execution FAILED!")


# ============================================================================
# Step 1: Expand High-Level Commands
# ============================================================================

def expand_high_level_commands(plan: List[Dict], memory: ObjectMemory) -> List[Dict]:
    """
    Expand PICK and PLACE into sequences of primitive commands.
    Pass through all other primitives unchanged.
    
    PICK(target) expands to:
      1. RELEASE
      2. MOVE_TO(target)
      3. ROT_YAW(grasp_angle)  # from object's orientation in memory
      4. GRAB
      5. MOVE_TO(REST_POSITION)
      6. ROT_YAW(REST_YAW_ANGLE)
    
    PLACE(destination, offset?) expands to:
      1. MOVE_TO(destination, offset)
      2. RELEASE
      3. MOVE_TO(REST_POSITION)
      4. ROT_YAW(REST_YAW_ANGLE)
    """
    expanded = []
    
    for i, task in enumerate(plan, 1):
        command = task.get("command", "").upper()
        
        if command == "PICK":
            print(f"[Tasks] Expanding PICK command {i}...")
            target = task.get("target")
            
            # Get grasp orientation for this object
            grasp_angle = get_grasp_orientation(target, memory)
            
            # Expand to primitive sequence
            expanded.extend([
                {"command": "RELEASE"},
                {"command": "MOVE_TO", "destination": target},
                {"command": "ROT_YAW", "angle": grasp_angle},
                {"command": "GRAB"},
                {"command": "MOVE_TO", "destination": C.REST_POSITION},
                {"command": "ROT_YAW", "angle": C.REST_YAW_ANGLE},
            ])
            print(f"[Tasks]   Expanded to 6 primitives")
        
        elif command == "PLACE":
            print(f"[Tasks] Expanding PLACE command {i}...")
            destination = task.get("destination")
            offset = task.get("offset", [0, 0, 0])
            
            # Expand to primitive sequence
            expanded.extend([
                {"command": "MOVE_TO", "destination": destination, "offset": offset},
                {"command": "RELEASE"},
                {"command": "MOVE_TO", "destination": C.REST_POSITION},
                {"command": "ROT_YAW", "angle": C.REST_YAW_ANGLE},
            ])
            print(f"[Tasks]   Expanded to 4 primitives")
        
        else:
            # Pass through primitives unchanged
            expanded.append(copy.deepcopy(task))
    
    return expanded

# TODO: Ensure that orientation is added to memory before this function is called
def get_grasp_orientation(target: Any, memory: ObjectMemory) -> float:
    """
    Get the grasp orientation (yaw angle) for a target object.
    
    If target is an object ID, retrieves the orientation from memory.
    If target is coordinates, returns default angle (0.0).
    
    Returns:
        Yaw angle in degrees for grasping
    """
    if isinstance(target, str):
        # Object ID - look up in memory
        obj = memory.get_object(target)
        if obj:
            # Check if object has orientation data
            orientation = obj.get("orientation", {})
            if orientation:
                yaw = orientation.get("yaw_deg", 0.0)
                conf = orientation.get("confidence", 0.0)
                print(f"[Tasks] Object {target} grasp angle: {yaw:.1f}° (confidence: {conf:.2f})")
                return yaw
            else:
                print(f"[Tasks] Object {target} has no orientation data, using default (0.0°)")
                return 0.0
        else:
            print(f"[Tasks] Warning: Object {target} not found in memory, using default angle (0.0°)")
            return 0.0
    else:
        # Coordinates - no object-specific orientation
        return 0.0


# ============================================================================
# Step 2: Resolve Object IDs and Apply Offsets
# ============================================================================

def resolve_object_ids_and_offsets(plan: List[Dict], memory: ObjectMemory) -> List[Dict]:
    """
    Convert object IDs to XYZ coordinates and apply offsets.
    
    Input format:
      {"command": "MOVE_TO", "destination": "0xOBJ123", "offset": [10, 0, 0]}
    
    Output format:
      {"command": "MOVE_TO", "x": 1210, "y": 800, "z": 500}  # offset applied
    
    For commands without destination/target, passes through unchanged.
    """
    resolved = []
    
    for i, task in enumerate(plan, 1):
        command = task.get("command", "").upper()
        new_task = {"command": command}
        
        if command == "MOVE_TO":
            # Resolve destination and apply offset
            destination = task.get("destination")
            offset = task.get("offset", [0, 0, 0])
            
            xyz = _resolve_to_xyz(destination, memory)
            if xyz:
                # Apply offset
                new_task["x"] = xyz[0] + offset[0]
                new_task["y"] = xyz[1] + offset[1]
                new_task["z"] = xyz[2] + offset[2]
                print(f"[Tasks] MOVE_TO resolved: xyz=[{new_task['x']}, {new_task['y']}, {new_task['z']}] mm")
            else:
                print(f"[Tasks] Warning: Could not resolve MOVE_TO destination: {destination}")
                continue  # Skip this command
        
        elif command in ("ROT_YAW", "ROT_PITCH"):
            # Copy angle parameter
            new_task["angle"] = task.get("angle", 0.0)
            print(f"[Tasks] {command} angle: {new_task['angle']:.1f}°")
        
        elif command in ("GRAB", "RELEASE"):
            # No parameters needed
            print(f"[Tasks] {command} (no parameters)")
        
        else:
            print(f"[Tasks] Warning: Unknown command {command}, skipping")
            continue
        
        resolved.append(new_task)
    
    return resolved


def _resolve_to_xyz(target: Any, memory: ObjectMemory) -> Optional[List[float]]:
    """
    Resolve a target (object ID or coordinates) to XYZ coordinates in millimeters.
    
    Args:
        target: Object ID string (e.g., "0xA1B2C3D4") or coordinate list [x, y, z]
        memory: ObjectMemory instance
    
    Returns:
        [x_mm, y_mm, z_mm] or None if resolution fails
    """
    if isinstance(target, str):
        # Object ID - look up in memory
        obj = memory.get_object(target)
        if obj:
            x = obj.get("x", 0.0)
            y = obj.get("y", 0.0)
            z = obj.get("z", 0.0)
            print(f"[Tasks]   Resolved object {target} to [{x}, {y}, {z}] mm")
            return [x, y, z]
        else:
            print(f"[Tasks]   Error: Object {target} not found in memory")
            return None
    
    elif isinstance(target, (list, tuple)) and len(target) == 3:
        # Already coordinates
        xyz = [float(target[0]), float(target[1]), float(target[2])]
        print(f"[Tasks]   Using provided coordinates [{xyz[0]}, {xyz[1]}, {xyz[2]}] mm")
        return xyz
    
    else:
        print(f"[Tasks]   Error: Invalid target format: {target}")
        return None


# ============================================================================
# Step 3: Convert to Protocol Format
# ============================================================================
# TODO: Remove later (not needed anymore)
def convert_to_protocol_format(plan: List[Dict]) -> List[Dict]:
    """
    Convert resolved commands to protocol format using P.CMD_* constants.
    
    Input format (from resolve step):
      {"command": "MOVE_TO", "x": 1200, "y": 800, "z": 500}
      {"command": "GRAB"}
      {"command": "ROT_YAW", "angle": 45.0}
    
    Output format (for network transmission):
      {"cmd": P.CMD_MOVE_TO, "x": 1200, "y": 800, "z": 500}
      {"cmd": P.CMD_GRAB}
      {"cmd": P.CMD_ROT_YAW, "angle": 45.0}
    
    Where P.CMD_MOVE_TO = "MOVE_TO", P.CMD_GRAB = "GRAB", etc.
    """
    protocol_commands = []
    
    for task in plan:
        command = task.get("command", "").upper()
        
        if command == "MOVE_TO":
            protocol_commands.append({
                "cmd": P.CMD_MOVE_TO,
                "x": task["x"],
                "y": task["y"],
                "z": task["z"],
            })
        
        elif command == "GRAB":
            protocol_commands.append({
                "cmd": P.CMD_GRAB,
            })
        
        elif command == "RELEASE":
            protocol_commands.append({
                "cmd": P.CMD_RELEASE,
            })
        
        elif command == "ROT_YAW":
            protocol_commands.append({
                "cmd": P.CMD_ROT_YAW,
                "angle": task["angle"],
            })
        
        elif command == "ROT_PITCH":
            protocol_commands.append({
                "cmd": P.CMD_ROT_PITCH,
                "angle": task["angle"],
            })
        
        else:
            print(f"[Tasks] Warning: Unknown command {command} in protocol conversion")
    
    return protocol_commands
