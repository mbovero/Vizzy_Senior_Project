# vizzy/laptop/tasks.py
"""
Task execution system for Vizzy robotic arm.

Flow:
1. LLM outputs high-level commands (PICK, PLACE) and primitives (GRAB, RELEASE, MOVE_TO, ROT_YAW, ROT_PITCH)
2. expand_high_level_commands() expands PICK/PLACE into primitive sequences
3. resolve_object_ids_and_offsets() converts object IDs to XYZ coordinates and applies offsets
4. convert_to_protocol_format() converts command names to protocol format (e.g., "MOVE_TO" → {"cmd": P.CMD_MOVE_TO, ...})
5. execute_plan() sends primitives one-at-a-time to RPi via dispatcher
"""

from __future__ import annotations

from typing import Any, List, Dict, Optional
import copy

from ..shared import protocol as P
from ..shared import config as C
from .memory import ObjectMemory


def execute_plan(
    *,
    plan: List[Dict[str, Any]],  # LLM output: high-level + primitives
    dispatcher,  # CommandDispatcher instance
    memory: ObjectMemory,
) -> None:
    """
    Execute a plan generated by the LLM task scheduler.
    
    Steps:
    1. Expand high-level commands (PICK, PLACE) into primitives
    2. Resolve object IDs to XYZ coordinates and apply offsets
    3. Convert to protocol format
    4. Send to RPi via dispatcher
    
    Plan format (from LLM): List of task dictionaries with:
      - command: PICK, PLACE, GRAB, RELEASE, MOVE_TO, ROT_YAW, ROT_PITCH
      - target: object_id or [x_mm, y_mm, z_mm] (for PICK)
      - destination: object_id or [x_mm, y_mm, z_mm] (for PLACE, MOVE_TO)
      - offset: [x_mm, y_mm, z_mm] (optional, for PLACE and MOVE_TO)
      - angle: float (for ROT_YAW, ROT_PITCH)
    """
    if not plan:
        print("[Tasks] (noop) No tasks in plan.")
        return

    print(f"[Tasks] Received plan with {len(plan)} command(s) from LLM")
    
    # Step 1: Expand high-level commands
    print("[Tasks] Step 1: Expanding high-level commands...")
    expanded_plan = expand_high_level_commands(plan, memory)
    print(f"[Tasks] Expanded to {len(expanded_plan)} primitive(s)")
    
    # Step 2: Resolve object IDs and apply offsets
    print("[Tasks] Step 2: Resolving object IDs and applying offsets...")
    resolved_plan = resolve_object_ids_and_offsets(expanded_plan, memory)
    print(f"[Tasks] Resolved {len(resolved_plan)} command(s)")
    
    # Step 3: Convert to protocol format
    print("[Tasks] Step 3: Converting to protocol format...")
    protocol_commands = convert_to_protocol_format(resolved_plan)
    print(f"[Tasks] Generated {len(protocol_commands)} protocol command(s)")
    
    # Step 4: Execute via dispatcher
    print("[Tasks] Step 4: Executing via dispatcher...")
    success = dispatcher.execute_primitives(protocol_commands)
    
    if success:
        print("[Tasks] Plan execution completed successfully!")
    else:
        print("[Tasks] Plan execution FAILED!")


# ============================================================================
# Step 1: Expand High-Level Commands
# ============================================================================

def expand_high_level_commands(plan: List[Dict], memory: ObjectMemory) -> List[Dict]:
    """
    Expand PICK and PLACE into sequences of primitive commands.
    Pass through all other primitives unchanged.
    
    PICK(target) expands to:
      1. RELEASE
      2. MOVE_TO(target + vertical_offset, pitch=-π/2)  # Approach from above
      3. ROT_YAW(grasp_angle)  # from object's orientation in memory
      4. MOVE_TO(target, pitch=-π/2)  # Descend to object
      5. GRAB
      6. MOVE_TO(REST_POSITION, pitch=REST_PITCH_ANGLE)
      7. ROT_YAW(REST_YAW_ANGLE)
    
    PLACE(destination, offset?, yaw_rot?) expands to:
      1. ROT_YAW(yaw_rot)  # Optional rotation before placing
      2. MOVE_TO(destination + offset + vertical_offset, pitch=-π/2)  # Approach from above
      3. RELEASE
      4. MOVE_TO(REST_POSITION, pitch=REST_PITCH_ANGLE)
      5. ROT_YAW(REST_YAW_ANGLE)
    """
    expanded = []
    
    for i, task in enumerate(plan, 1):
        command = task.get("command", "").upper()
        
        if command == "PICK":
            print(f"[Tasks] Expanding PICK command {i}...")
            target = task.get("target")
            
            # Get grasp orientation for this object
            grasp_angle = get_grasp_orientation(target, memory)
            
            # Expand to primitive sequence with approach offset
            vertical_offset = [0, 0, C.APPROACH_OFFSET_Z]
            expanded.extend([
                {"command": "RELEASE"},
                {"command": "MOVE_TO", "destination": target, "offset": vertical_offset, "pitch": -90.0},
                {"command": "ROT_YAW", "angle": grasp_angle},
                {"command": "MOVE_TO", "destination": target, "pitch": -90.0},
                {"command": "GRAB"},
                {"command": "MOVE_TO", "destination": C.REST_POSITION, "pitch": C.REST_PITCH_ANGLE},
                {"command": "ROT_YAW", "angle": C.REST_YAW_ANGLE},
            ])
            print(f"[Tasks]   Expanded to 7 primitives")
        
        elif command == "PLACE":
            print(f"[Tasks] Expanding PLACE command {i}...")
            destination = task.get("destination")
            offset = task.get("offset", [0, 0, 0])
            yaw_rot = task.get("yaw_rot", None)  # Optional yaw rotation
            
            # Expand to primitive sequence with approach offset
            vertical_offset = [0, 0, C.APPROACH_OFFSET_Z]
            
            # Combine user offset + vertical approach offset
            combined_offset = [
                offset[0] + vertical_offset[0],
                offset[1] + vertical_offset[1],
                offset[2] + vertical_offset[2]
            ]
            
            primitives = []
            if yaw_rot is not None:
                primitives.append({"command": "ROT_YAW", "angle": yaw_rot})
            
            primitives.extend([
                {"command": "MOVE_TO", "destination": destination, "offset": combined_offset, "pitch": -90.0},
                {"command": "RELEASE"},
                {"command": "MOVE_TO", "destination": C.REST_POSITION, "pitch": C.REST_PITCH_ANGLE},
                {"command": "ROT_YAW", "angle": C.REST_YAW_ANGLE},
            ])
            
            expanded.extend(primitives)
            print(f"[Tasks]   Expanded to {len(primitives)} primitives")
        
        else:
            # Pass through primitives unchanged
            expanded.append(copy.deepcopy(task))
    
    return expanded


def get_grasp_orientation(target: Any, memory: ObjectMemory) -> float:
    """
    Get the grasp orientation (yaw angle) for a target object.
    
    If target is an object ID, retrieves the orientation from memory.
    If target is coordinates, returns default angle (0.0).
    
    Returns:
        Yaw angle in degrees for grasping (converted from radians stored in memory)
    """
    import math
    if isinstance(target, str):
        # Object ID - look up in memory
        obj = memory.get_object(target)
        if obj:
            # Check if object has orientation data
            orientation = obj.get("orientation", {})
            yaw_rad = orientation.get("grasp_yaw", 0.0)
            # Convert from radians (stored) to degrees (expected by ROT_YAW command)
            yaw_deg = math.degrees(yaw_rad)
            print(f"[Tasks] Object {target} grasp angle: {yaw_rad:.4f} rad -> {yaw_deg:.1f}°")
            return yaw_deg
        else:
            print(f"[Tasks] Warning: Object {target} not found in memory, using default angle (0.0°)")
            return 0.0
    else:
        # Coordinates - no object-specific orientation
        return 0.0


# ============================================================================
# Step 2: Resolve Object IDs and Apply Offsets
# ============================================================================

def resolve_object_ids_and_offsets(plan: List[Dict], memory: ObjectMemory) -> List[Dict]:
    """
    Convert object IDs to XYZ coordinates and apply offsets.
    
    Input format:
      {"command": "MOVE_TO", "destination": "0xOBJ123", "offset": [10, 0, 0], "pitch": -90.0}
    
    Output format:
      {"command": "MOVE_TO", "x": 1210, "y": 800, "z": 500, "pitch": -90.0}  # offset applied
    
    For commands without destination/target, passes through unchanged.
    """
    resolved = []
    
    for i, task in enumerate(plan, 1):
        command = task.get("command", "").upper()
        new_task = {"command": command}
        
        if command == "MOVE_TO":
            # Resolve destination and apply offset
            destination = task.get("destination")
            offset = task.get("offset", [0, 0, 0])
            pitch = task.get("pitch", C.REST_PITCH_ANGLE)  # Use specified pitch or default
            
            xyz = _resolve_to_xyz(destination, memory)
            if xyz:
                # Apply offset
                new_task["x"] = xyz[0] + offset[0]
                new_task["y"] = xyz[1] + offset[1]
                new_task["z"] = xyz[2] + offset[2]
                new_task["pitch"] = pitch
                print(f"[Tasks] MOVE_TO resolved: xyz=[{new_task['x']:.1f}, {new_task['y']:.1f}, {new_task['z']:.1f}] mm pitch={new_task['pitch']:.1f}°")
            else:
                print(f"[Tasks] Warning: Could not resolve MOVE_TO destination: {destination}")
                continue  # Skip this command
        
        elif command in ("ROT_YAW", "ROT_PITCH"):
            # Copy angle parameter
            new_task["angle"] = task.get("angle", 0.0)
            print(f"[Tasks] {command} angle: {new_task['angle']:.1f}°")
        
        elif command in ("GRAB", "RELEASE"):
            # No parameters needed
            print(f"[Tasks] {command} (no parameters)")
        
        else:
            print(f"[Tasks] Warning: Unknown command {command}, skipping")
            continue
        
        resolved.append(new_task)
    
    return resolved


def _resolve_to_xyz(target: Any, memory: ObjectMemory) -> Optional[List[float]]:
    """
    Resolve a target (object ID or coordinates) to XYZ coordinates in millimeters.
    Returns [x, y, z] or None if resolution fails.
    """
    if isinstance(target, str):
        obj = memory.get_object(target)
        if obj:
            x = float(obj.get("x", 0.0))
            y = float(obj.get("y", 0.0))
            z = float(obj.get("z", 0.0))
            print(f"[Tasks]   Resolved object {target} to [{x:.1f}, {y:.1f}, {z:.1f}] mm")
            return [x, y, z]
        print(f"[Tasks]   Error: Object {target} not found in memory")
        return None

    if isinstance(target, (list, tuple)) and len(target) == 3:
        x = float(target[0])
        y = float(target[1])
        z = float(target[2])
        print(f"[Tasks]   Using provided coordinates [{x:.1f}, {y:.1f}, {z:.1f}] mm")
        return [x, y, z]

    print(f"[Tasks]   Error: Invalid target format: {target}")
    return None


# ============================================================================
# Step 3: Convert to Protocol Format
# ============================================================================

def convert_to_protocol_format(plan: List[Dict]) -> List[Dict]:
    """
    Convert resolved commands to protocol format using P.CMD_* constants.
    
    Input format (from resolve step):
      {"command": "MOVE_TO", "x": 1200, "y": 800, "z": 500, "pitch": 0.0}
      {"command": "GRAB"}
      {"command": "ROT_YAW", "angle": 45.0}
    
    Output format (for network transmission):
      {"cmd": P.CMD_MOVE_TO, "x": 1200, "y": 800, "z": 500, "pitch": 0.0}
      {"cmd": P.CMD_GRAB}
      {"cmd": P.CMD_ROT_YAW, "angle": 45.0}
    
    Where P.CMD_MOVE_TO = "MOVE_TO", P.CMD_GRAB = "GRAB", etc.
    """
    protocol_commands = []
    
    for task in plan:
        command = task.get("command", "").upper()
        
        if command == "MOVE_TO":
            protocol_commands.append({
                "cmd": P.CMD_MOVE_TO,
                "x": task["x"],
                "y": task["y"],
                "z": task["z"],
                "pitch": task["pitch"],
            })
        
        elif command == "GRAB":
            protocol_commands.append({
                "cmd": P.CMD_GRAB,
            })
        
        elif command == "RELEASE":
            protocol_commands.append({
                "cmd": P.CMD_RELEASE,
            })
        
        elif command == "ROT_YAW":
            protocol_commands.append({
                "cmd": P.CMD_ROT_YAW,
                "angle": task["angle"],
            })
        
        elif command == "ROT_PITCH":
            protocol_commands.append({
                "cmd": P.CMD_ROT_PITCH,
                "angle": task["angle"],
            })
        
        else:
            print(f"[Tasks] Warning: Unknown command {command} in protocol conversion")
    
    return protocol_commands
